package soot.jimple.infoflow.spring;

import soot.*;
import soot.javaToJimple.LocalGenerator;
import soot.jimple.infoflow.entryPointCreators.BaseEntryPointCreator;
import soot.jimple.infoflow.util.SootMethodRepresentationParser;

import java.util.*;

/**
 * This entry point creator will accept a collection of method names that are
 * marked with @RequestMapping or similar annotation, and randomly call these
 * methods in different sequences, with tainted params passed in.
 * <p>
 * The main difference between this class and the default
 * Created by Charlie on 04. 03 2019
 */
public class SpringAppEntryPointCreator extends BaseEntryPointCreator {
    /**
     * Config object to control behaviour of the entry point creator
     */
    public static class AnalysisConfig {
        /**
         * Full soot-style method signature specifying a method that take
         * no input param and return a tainted String
         *
         * the default value is reading from standard input
         */
        public String defaultTaintSource = "<java.util.Scanner: java.lang.String nextLine()>";

        public AnalysisConfig() {
        }
    }

    private List<String> methodsToCall;

    private AnalysisConfig config = new AnalysisConfig();

    public SpringAppEntryPointCreator(List<String> methodsToCall) {
        super();
        this.methodsToCall = methodsToCall;
    }

    public SpringAppEntryPointCreator(List<String> methodsToCall, AnalysisConfig config) {
        this(methodsToCall);
        this.config = config;
    }

    /**
     * the main method created will looks like following
     *
     * Scanner scanner = new Scanner(System.in);
     * String defaultTaintSource = scanner.nextLine();
     *
     * // methods invocations
     * // String params will be passed in with the tainted value
     * // other params will be automatically generated by the LocalGenerator
     *
     * new TargetObject1().method1(defaultTaintSource, new ParamClass(), null, ...);
     * ... method calls to other target methods
     *
     * @return main method(SootMethod instance)
     */
    @Override
    protected SootMethod createDummyMainInternal() {
        Map<String, Set<String>> classMap =
                SootMethodRepresentationParser.v().parseClassNames(methodsToCall, false);

        Body body = mainMethod.getActiveBody();
        LocalGenerator generator = new LocalGenerator(body);

        // generate a default taint source as local var
        Local defaultTaintSource = generator.generateLocal(RefType.v("java.lang.String"));

        HashMap<String, Local> localVarsForClasses = new HashMap<>();

        // create instance of each target class
        // so that we could invoke target methods on them
        for (String className : classMap.keySet()) {
            SootClass createdClass = Scene.v().forceResolve(className, SootClass.BODIES);
            createdClass.setApplicationClass();

            Local localVal = generateClassConstructor(createdClass, body);
            if (localVal == null) {
                logger.warn("Cannot generate constructor for class: {}", createdClass);
                continue;
            }
            localVarsForClasses.put(className, localVal);
        }

        return mainMethod;
    }

    @Override
    public Collection<String> getRequiredClasses() {
        return null;
    }

    @Override
    public Collection<SootMethod> getAdditionalMethods() {
        return null;
    }

    @Override
    public Collection<SootField> getAdditionalFields() {
        return null;
    }


}